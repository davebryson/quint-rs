use std::iter::once;
use crate::{QuintEx, QuintName};
use crate::utils::QuintIdGenerator;
use crate::lexer::{Token, LexicalError};

grammar(id: &mut QuintIdGenerator);

// Change entry to pub Quint:
// Using tiers, you work from bottom up...
// reverse of below...
// 
// 

pub Expression: QuintEx = {
    Pair,
    Tuple,
    Record,
    IfThenExp,
}

KeyValue: (QuintEx, QuintEx) = {
    <lhs:Identifier> ":" <rhs:Expression> ","? => {
        (QuintEx::QuintStr{id: id.get(), value: lhs}, rhs)
    },
}

Record: QuintEx = {
    "{" <a:KeyValue*> "}" => {
        QuintEx::QuintApp {
            id:id.get(), 
            opcode: "Rec".into(),
            args: a.iter()
            .flat_map(|tup| once(tup.0.clone()).chain(once(tup.1.clone())))
            .collect::<Vec<_>>(),
        }
    },

    "{" <a:KeyValue*> "}" "." <b: Identifier> => {
        let rec = QuintEx::QuintApp {
            id:id.get(), 
            opcode: "Rec".into(),
            args: a.iter()
            .flat_map(|tup| once(tup.0.clone()).chain(once(tup.1.clone())))
            .collect::<Vec<_>>(),
        };
        QuintEx::QuintApp {
           id:id.get(), 
            opcode: "field".into(),
            args: vec![rec, QuintEx::QuintStr{id: id.get(), value: b}]
        }
    },
}

// *** Expressions *** // 
IfThenExp: QuintEx = {
    "if" <a:AndOrExp> <b:AtomExp> "else" <c:AtomExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "ite".into(),
            args: vec![a,b,c],
        }
    },
    AndOrExp,
}

// Literal List 
LiteralList: QuintEx = {
    "[" <args:Comma<AtomExp>> "]" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "List".into(), 
            args,
        }
    },
}

AndOrOps: QuintName = {
    "and" => "and".into(),
    "or" => "or".into(),
    "implies" => "implies".into(),
    "iff" => "iff".into()
}
AndOrExp: QuintEx = {
    <lhs:Expression> <opcode: AndOrOps> <rhs:RelationshipExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode,
            args: vec![lhs, rhs],
        }
    },
    "and" "{" <args:CommaOne<RelationshipExp>> "}" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "and".into(), 
            args,
        }
    },
    "or" "{" <args:CommaOne<RelationshipExp>> "}" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "or".into(), 
            args,
        }
    },
    "all" "{" <args:CommaOne<RelationshipExp>> "}" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "actionAll".into(), 
            args,
        }
    },
    "any" "{" <args:CommaOne<RelationshipExp>> "}" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "actionAny".into(), 
            args,
        }
    },
    RelationshipExp,
    //PrimeExp,
}

// Prime Assignment
// TODO: this will have an opcode of 'assign' and 2 args. 
// See: line 508 in evaluator.  assumes the lhs was declared earlier
//PrimeExp: QuintEx = {
//    <lhs: Identifier> "'" "=" <rhs:RelationshipExp> => {
//        QuintEx::QuintApp{
//            id:id.get(), 
//            opcode: "assign".into(), 
//            args: vec![QuintEx::QuintStr{id: id.get(), value: lhs}, rhs],
//        }
//    },
//    RelationshipExp,
//}

// Relations
RelationshipOps: QuintName = {
    ">" => "igt".into(),
    ">=" => "igte".into(),
    "<" => "ilt".into(),
    "<=" => "ilte".into(),
    "!=" => "neq".into(),
    "==" => "eq".into(),
}
RelationshipExp: QuintEx = {
    <lhs:RelationshipExp> <opcode: RelationshipOps> <rhs:ArithmeticExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode, 
            args: vec![lhs, rhs],
        }
    },
    ArithmeticExp,
}

ArithmeticOps: QuintName = {
    "+" => "iadd".into(),
    "-" => "isub".into(),
}
ArithmeticExp: QuintEx = {
    <lhs:ArithmeticExp> <opcode: ArithmeticOps> <rhs:MulDivModExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode, 
            args: vec![lhs, rhs],
        }
    },
    MulDivModExp,
}

MulDivModOps: QuintName = {
    "*" => "imul".into(),
    "/" => "idiv".into(),
    "%" => "imod".into(),
}
MulDivModExp: QuintEx = {
    <lhs:MulDivModExp> <opcode: MulDivModOps> <rhs:AtomExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode, 
            args: vec![lhs, rhs],
        }
    },
    UminusExp,
}

UminusExp: QuintEx = {
    "-" <rhs:UminusExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "iuminus".into(), 
            args:  vec![rhs],
        }
    },
    PowExp,
}

// right associative
PowExp: QuintEx = {
    <lhs:AtomExp> "^" <rhs:UminusExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "ipow".into(), 
            args:  vec![lhs, rhs],
        }
    },
    //OperApp,
    ListAccess,
}

// [1,2,3][1], List(1,3)[1]
ListAccess: QuintEx = {
    <n:OperApp> "[" <idx: Number> "]" => {
        QuintEx::QuintApp{
            id: id.get(), 
            opcode: "nth".into(), 
            args: vec![n, idx],
        }
    },
    OperApp,
}

CallName: QuintName = {
    AndOrOps,
    Identifier,
}
// OperApp
OperApp: QuintEx = {
    <n: CallName> "(" <args:Comma<DotCall>> ")" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: n, 
            args,
        }
    },
    DotCall,
}

// Lambda

// Dot Call
DotCall: QuintEx = {
    // TODO: this needs to support optional: (args), e.g. {}.a
    <n:OperApp> "." <opcode: CallName> "(" <mut args:Comma<OperApp>> ")" => {
        let mut v = vec![n];
        v.append(&mut args);
        QuintEx::QuintApp{
            id: id.get(), 
            opcode, 
            args: v,
        }
    },
    LiteralList,
    AtomExp,
}

// Change to Atom?
AtomExp: QuintEx = {
    Number, 
    Str,
    Boolean,
    "(" <e:Expression> ")" => e,
    "{" <e:Expression> "}" => e,
    // Tuple 'uint'
    "("")" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "Tup".into(),
            args: vec![]
        }
    },
}

/** Structures **/

Pair: QuintEx = {
    <lhs: AtomExp> "->" <rhs:AtomExp> => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "Tup".into(),
            args: vec![lhs,rhs]
        }
    },
}

// Tuple
TupleItem: QuintEx = {
    "." "_" <value: Number> => <>
}

Tuple: QuintEx = {
    "(" <args: CommaTwo<Expression>> ")" => {
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "Tup".into(),
            args,
        }
    },
    // With item
    "(" <args: CommaTwo<Expression>> ")" <idx: TupleItem> => {
        //args.push(idx);
        let a = QuintEx::QuintApp{
            id:id.get(), 
            opcode: "Tup".into(),
            args,
        };
        QuintEx::QuintApp{
            id:id.get(), 
            opcode: "item".into(),
            args: vec![a, idx]
        }
    },
}


/** qualId, etc... */
Identifier: QuintName = {
    <name:LowId> => name.into(),
    <name:CapId> => name.into(),
    "Set" => "Set".into(),
    "List" => "List".into(),
    "from" => "from".into(),
    "as" => "as".into(),
}

/** Literals **/
Number: QuintEx = {
    <value:Int> => QuintEx::QuintInt{id: id.get(), value},
    <value:Hex> => QuintEx::QuintInt{id: id.get(), value},
}
Str: QuintEx = {
    <value:String> => QuintEx::QuintStr{id: id.get(), value: value.into()}
}
Boolean: QuintEx = {
    <value:Bool> => QuintEx::QuintBool{id: id.get(), value}
}

/** Macro for handling arguments: (1,2,), etc.. **/
#[inline]
Comma<T>: Vec<T> = {
    => Vec::new(),
    CommaOne<T> => <>,
};
CommaOne<T>: Vec<T> = {
    <e:T> <v:("," <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};
CommaTwo<T>: Vec<T> = {
    <e:T> <v:("," <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

// Lexer mapping
extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    Int => Token::Int(<i64>),
    Hex => Token::Hex(<i64>),
    Bool => Token::Bool(<bool>),
    CapId => Token::CapId(<String>),
    LowId => Token::LowId(<String>),
    String => Token::String(<String>),

    "+" => Token::Add,
    "-" => Token::Sub,
    "*" => Token::Mul,
    "/" => Token::Div,
    "%" => Token::Mod,

    "=" => Token::Assign,
    "==" => Token::EQ,
    "!=" => Token::NE,
    ">" => Token::GT,
    "<" => Token::LT,
    ">=" => Token::GE,
    "<=" => Token::LE,

    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::SemiColon,
    "::" => Token::DoubleColon,
    "." => Token::Period,
    "'" => Token::Prime,
    "|" => Token::Pipe,
    "->" => Token::Arrow,
    "=>" => Token::DoubleArrow,
    "^" => Token::Hat,
    "_" => Token::Underscore,
    "..." => Token::Ellipsis,

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,

    "module" => Token::Module,
    "const" => Token::Const,
    "assume" => Token::Assume,
    "var" => Token::Var,
    "val" => Token::Val,
    "def" => Token::Def,
    "pure" => Token::Pure,
    "action" => Token::Action,
    "temporal" => Token::Temporal,
    "nondet" => Token::Nondet,
    "run" => Token::Run,

    "all" => Token::All,
    "any" => Token::Any,
    "all" => Token::All,
    "if" => Token::If,
    "iff" => Token::Iff,
    "else" => Token::Else,
    "and" => Token::And,
    "or" => Token::Or,
    "implies" => Token::Implies,
    "match" => Token::Match,

    "Set" => Token::Set,
    "List" => Token::List,

    "import" => Token::Import,
    "export" => Token::Export,

    "as" => Token::As,
    "from" => Token::From,

    "type" => Token::Type,
    "str" => Token::TypeStr,
    "int" => Token::TypeInt,
    "bool" => Token::TypeBool,

    "/*" => Token::Comment,
  }
}
