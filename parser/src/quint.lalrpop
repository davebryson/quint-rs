use crate::{QuintEx, QuintDeclaration, QuintVar};
use crate::utils::{QuintIdGenerator, make_quint_app};
use crate::lexer::{Token, LexicalError};

grammar(helper: &mut QuintIdGenerator);


QuintDeclaration: QuintDeclaration = {
  "var" <name:"identifier"> ":" "int" => {
    QuintDeclaration::QuintVar(
      QuintVar{
        id: helper.get_id(), 
        name: name.into(), 
        imported_from: None, 
        namespaces: None
      }
    )
  }
}


// TODO: refactor for precedence...
pub QuintEx: QuintEx = {
    #[precedence(level="0")]
    ExpTerm,


    #[assoc(side="right")]
    #[precedence(level="1")]
    <lhs:QuintEx> "^" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "ipow", vec![lhs, rhs])
    },

    // operators
    #[assoc(side="left")]
    #[precedence(level="3")]
    <lhs:QuintEx> "*" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "imul", vec![lhs, rhs])
    },
    <lhs:QuintEx> "/" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "idiv", vec![lhs, rhs])
    },
    <lhs:QuintEx> "%" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "imod", vec![lhs, rhs])
    },

    #[assoc(side="left")]
    #[precedence(level="4")]
    <lhs:QuintEx> "+" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "iadd", vec![lhs, rhs])
    },
    <lhs:QuintEx> "-" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "isub", vec![lhs, rhs])
    },

    // relations
    <lhs:QuintEx> ">" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "igt", vec![lhs, rhs])
    },
    <lhs:QuintEx> ">=" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "igte", vec![lhs, rhs])
    },
    <lhs:QuintEx> "<" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "ilt", vec![lhs, rhs])
    },
    <lhs:QuintEx> "<=" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "ilte", vec![lhs, rhs])
    },
    <lhs:QuintEx> "!=" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "neq", vec![lhs, rhs])
    },
    <lhs:QuintEx> "==" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "eq", vec![lhs, rhs])
    },

    <lhs:QuintEx> "and" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "and", vec![lhs, rhs])
    },
    <lhs:QuintEx> "or" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "or", vec![lhs, rhs])
    },

    <lhs:QuintEx> "implies" <rhs:QuintEx> => {
        make_quint_app(helper.get_id(), "implies", vec![lhs, rhs])
    },

    // if then else
    "if" <c:ExpTerm> <a:QuintEx> "else" <b:QuintEx> => {
        make_quint_app(helper.get_id(), "ite", vec![c, a, b])
    },

    // list
    "[" <args:Comma<QuintEx>> "]" => {
        make_quint_app(helper.get_id(), "List", args)
    },
}


ExpTerm: QuintEx = {
  <value:"int"> => {
    QuintEx::QuintInt{id: helper.get_id(), value}
  },
  <value:"str"> => {
    QuintEx::QuintStr{id: helper.get_id(), value: value.into()}
  },
  <value:"bool"> => {
    QuintEx::QuintBool{id: helper.get_id(), value}
  },
  <name:"identifier"> => {
    QuintEx::QuintName{id: helper.get_id(), name: name.into()}
  },
   "(" <e:QuintEx> ")" => e,
   "{" <e:QuintEx> "}" => e,
}

// macros for handling arguments: (1,2,), etc..
Comma<T>: Vec<T> = {
    => Vec::new(),
    CommaOne<T> => <>,
};

CommaOne<T>: Vec<T> = {
    <e:T> <v:("," <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

CommaTwo<T>: Vec<T> = {
    <e:T> <v:("," <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

// Lexer
extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "int" => Token::Int(<i64>),
    "str" => Token::String(<String>),
    "bool" => Token::Bool(<bool>),

    "identifier" => Token::LowId(<String>),
    "cap_id" => Token::CapId(<String>),

    "+" => Token::Add,
    "-" => Token::Sub,
    "*" => Token::Mul,
    "/" => Token::Div,
    "%" => Token::Mod,

    "=" => Token::Assign,
    "==" => Token::EQ,
    "!=" => Token::NE,
    ">" => Token::GT,
    "<" => Token::LT,
    ">=" => Token::GE,
    "<=" => Token::LE,

    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::SemiColon,
    "::" => Token::DoubleColon,
    "." => Token::Period,
    "'" => Token::Prime,
    "|" => Token::Pipe,
    "->" => Token::Arrow,
    "=>" => Token::DoubleArrow,
    "^" => Token::Hat,
    "_" => Token::Underscore,
    "..." => Token::Ellipsis,

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,

    "module" => Token::Module,
    "const" => Token::Const,
    "assume" => Token::Assume,
    "var" => Token::Var,
    "val" => Token::Val,
    "def" => Token::Def,
    "pure" => Token::Pure,
    "action" => Token::Action,
    "temporal" => Token::Temporal,
    "nondet" => Token::Nondet,
    "run" => Token::Run,

    "all" => Token::All,
    "any" => Token::Any,
    "all" => Token::All,
    "if" => Token::If,
    "iff" => Token::Iff,
    "else" => Token::Else,
    "and" => Token::And,
    "or" => Token::Or,
    "implies" => Token::Implies,
    "match" => Token::Match,

    "Set" => Token::Set,
    "List" => Token::List,

    "import" => Token::Import,
    "export" => Token::Export,

    "from" => Token::From,
    "as" => Token::As,

    "type" => Token::Type,

    "/*" => Token::Comment,
  }
}
